# Growing Context-Sensitive Grammars Parser

According to the Chomsky hierarchy, Growing context sensitive grammar is a type of context sensitive grammar that the production rule always increase in length.
The complexity of the membership problem is in polynomial time. But it's very hard to implement even for the most capable AI of 2025.
In this repository, I try to do just that. Along with the baseline, recursive grammar and context-free grammar.

## Theory

### Growing Context-Sensitive Grammars

Growing context-sensitive grammars (GCSGs) are a subclass of context-sensitive grammars where the length of the right-hand side of each production rule is strictly greater than the length of the left-hand side. Formally, a GCSG is a 4-tuple G = (N, T, S, P) where:

-   N is a finite set of non-terminal symbols,
-   T is a finite set of terminal symbols,
-   S is the start symbol,
-   P is a finite set of production rules of the form αAβ → αγβ, where α, β ∈ (N ∪ T \ {S})∗, A ∈ N, γ ∈ (N ∪ T)+, and |γ| > |A|.

### Generalized CYK Algorithm

The polynomial-time membership of growing context-sensitive grammars can be articulated using a dynamic programming framework. This approach can be seen as a generalization of the Cocke-Kasami-Younger (CYK) algorithm used for context-free grammars, effectively leverages the length-increasing property of GCSGs.
At the core, the algorithm maintains and glows a table that keeps track of which non-terminal symbols can derive substrings of the input string. The generalized CYK algorithm for GCSGs can be described as follows:

Let x be an input string of length n. The goal is to determine if x ∈ L(G), where G is a GCSG and L(G) is the language generated by G.
Consider all possible substrings of x. For each substring and each non-terminal A in N, we want to determine if A can derive that substring.
For every non-terminal A and every substring y in x, if there is a production rule αAβ → αBβ in P, we need to check three things:

    1. Whether the prefix of y fits the left-hand side of the production rule α.
    2. Whether the suffix of y fits the right-hand side of the production rule β.
    3. Whether the B fits the substring y.

If all three conditions are met, we can conclude that A can fit y. We can use a dynamic programming table to keep track of this information.

"fit" here means the collection of symbols (which may contain both terminals and non-termianls) in the production rule can match the corresponding symbols in the substring. This is the problem of regular language membership, which can be solved in polynomial time.
We can employ another dynamic programming table to sort this out similarly to the dynamic time warp algorithm.

The crucial aspect here is that because the grammar is growing, we can incrementally do this from the substring of size 2 to the substring of size |x|.
The reason why we can skip the substring of size 1 is due to the growing property of the grammar. We can use UNIT operation from the conversion to Chomsky normal form to remove any unit production rules from the grammar.
Finally, we check if the start symbol S fits the entire input string x.
The algorithm is guaranteed to terminate in polynomial time, and the time complexity is O(n<sup>6</sup>)|P|.
